# Руководство по составлению блок-схем в Draw.io для анализа нейросетями

## 1. Общие принципы оформления

### 1.1 Цветовая схема
- **Текст**: строго черный (`#000000`)
- **Фон блоков**: белый или без заливки
- **Границы блоков**: черные (`#000000`)
- **Толщина линий**: 1-2 пикселя для блоков, 2 пикселя для стрелок

**Исключение**: Можно использовать светлые пастельные цвета для группировки логических блоков, но текст всегда должен быть черным.

### 1.2 Шрифты
- **Семейство**: Times New Roman (стандарт для технической документации)
- **Размер**: 11-13 пунктов
- **Стиль**: обычный (без жирного/курсива, кроме заголовков)
- **Выравнивание**: по центру

### 1.3 Расстояния между элементами
- **Вертикальный отступ** между блоками: 20-30 пикселей
- **Горизонтальный отступ** для параллельных ветвей: минимум 100 пикселей
- **Отступ от стрелок до меток** ("Да"/"Нет"): 5-10 пикселей
- **Размер сетки**: 10 пикселей (для выравнивания)

## 2. Типы блоков и их применение

### 2.1 Базовые блоки

| Тип блока | Форма | Назначение | Размеры (рекомендуемые) |
|-----------|-------|------------|-------------------------|
| Начало/Конец | Овал | Начало и завершение алгоритма | 140×60 px |
| Процесс | Прямоугольник | Вычисления, присваивания | 200×40 px |
| Ввод/Вывод | Параллелограмм | Ввод данных, вывод результатов | 170×45 px |
| Условие | Ромб | Проверка условия (if, switch) | 140×70 px |
| Цикл for | Шестиугольник | Цикл с конструкцией `i=0; i<n; i++` | 220×50 px |
| Цикл while | Ромб | Цикл с проверкой условия | 140×70 px |
| Подпрограмма | Прямоугольник с двойными линиями | Вызов функции/процедуры | 160×50 px |

### 2.2 Примеры оформления в XML (Draw.io)

```xml
<!-- Начало/Конец -->
<mxCell style="ellipse;whiteSpace=wrap;html=1;strokeColor=#000000;fontSize=12;fontStyle=0;fontFamily=Times New Roman;"
        value="Начало" vertex="1">
  <mxGeometry height="60" width="140" x="344" y="50" as="geometry" />
</mxCell>

<!-- Процесс -->
<mxCell style="rounded=0;whiteSpace=wrap;html=1;strokeColor=#000000;fontSize=12;align=center;fontStyle=0;fontFamily=Times New Roman;"
        value="x = a + b" vertex="1">
  <mxGeometry height="40" width="200" x="314" y="195" as="geometry" />
</mxCell>

<!-- Ввод/Вывод -->
<mxCell style="shape=parallelogram;perimeter=parallelogramPerimeter;whiteSpace=wrap;html=1;strokeColor=#000000;fontSize=12;fontStyle=0;fontFamily=Times New Roman;"
        value="Ввод: a, b, c" vertex="1">
  <mxGeometry height="45" width="170" x="329" y="140" as="geometry" />
</mxCell>

<!-- Условие -->
<mxCell style="rhombus;whiteSpace=wrap;html=1;strokeColor=#000000;fontSize=12;fontStyle=0;fontFamily=Times New Roman;"
        value="x &gt; 0?" vertex="1">
  <mxGeometry height="70" width="140" x="344" y="230" as="geometry" />
</mxCell>

<!-- Цикл for -->
<mxCell style="shape=hexagon;perimeter=hexagonPerimeter2;whiteSpace=wrap;html=1;strokeColor=#000000;fontSize=12;align=center;fontStyle=0;fontFamily=Times New Roman;"
        value="i = 0; i &lt; n; i++" vertex="1">
  <mxGeometry height="50" width="220" x="304" y="265" as="geometry" />
</mxCell>

<!-- Цикл while (ромб) -->
<mxCell style="rhombus;whiteSpace=wrap;html=1;strokeColor=#000000;fontSize=12;fontStyle=0;fontFamily=Times New Roman;"
        value="условие?" vertex="1">
  <mxGeometry height="70" width="140" x="344" y="265" as="geometry" />
</mxCell>
```

## 3. Правильное оформление циклов

### 3.1 Цикл for (классический)

**Блок цикла** - шестиугольник, содержащий всю конструкцию: `i = 0; i < n; i++`

**Схема стрелок (4 соединения):**
```
         [вход сверху]
               ↓
         (entryX=0.5, entryY=0)
               ↓
      ┌────────────────────┐
      │   i=0; i<n; i++    │ (шестиугольник)
  ←───┤                    ├───→ [Выход из цикла]
слева └────────┬───────────┘ справа
(entryX=0)     ↓              (exitX=1, exitY=0.5)
               ↓              метка: "Нет"
          (exitX=0.5, exitY=1)
          метка: "Да"
               ↓
        [Тело цикла]
               │
               └──→ (возврат влево вверх к блоку цикла)
```

**Позиции точек подключения:**
- **Вход сверху**: `entryX=0.5, entryY=0` (центр верхней грани)
- **Выход вниз** (в тело): `exitX=0.5, exitY=1` (центр нижней грани)
- **Выход вправо** (из цикла): `exitX=1, exitY=0.5` (центр правой грани)
- **Возврат слева**: `entryX=0, entryY=0.5` (центр левой грани)

**Важно:**
- **Один блок** (шестиугольник) содержит: инициализацию, условие и инкремент
- **Три стрелки** (направления по позициям блока):
  1. **Сверху (entryX=0.5, entryY=0)** → входит в блок цикла (первый вход)
  2. **Снизу (exitX=0.5, exitY=1)** → выход в тело цикла (условие истинно, "Да")
  3. **Справа (exitX=1, exitY=0.5)** → выход из цикла (условие ложно, "Нет")
- **Возврат (entryX=0, entryY=0.5)**: после тела цикла стрелка возвращается **слева** в блок цикла
- Блок цикла автоматически выполняет инкремент при каждом возврате

**Пример XML для Draw.io:**
```xml
<!-- Блок цикла -->
<mxCell id="for_loop" style="shape=hexagon;perimeter=hexagonPerimeter2;whiteSpace=wrap;html=1;strokeColor=#000000;fontSize=12;align=center;fontStyle=0;fontFamily=Times New Roman;"
        value="i = 0; i &lt; n; i++" vertex="1">
  <mxGeometry height="50" width="220" x="304" y="265" as="geometry" />
</mxCell>

<!-- Стрелка вниз в тело цикла (Да) -->
<mxCell edge="1" parent="1" source="for_loop" target="loop_body"
        style="exitX=0.5;exitY=1;entryX=0.5;entryY=0;strokeWidth=2;">
  <mxGeometry relative="1" as="geometry" />
</mxCell>

<!-- Стрелка вправо - выход из цикла (Нет) -->
<mxCell edge="1" parent="1" source="for_loop" target="after_loop"
        style="exitX=1;exitY=0.5;entryX=0.5;entryY=0;strokeWidth=2;">
  <mxGeometry relative="1" as="geometry" />
</mxCell>

<!-- Стрелка возврата слева -->
<mxCell edge="1" parent="1" source="loop_body" target="for_loop"
        style="exitX=0;exitY=0.5;entryX=0;entryY=0.5;strokeWidth=2;">
  <mxGeometry relative="1" as="geometry">
    <Array as="points">
      <mxPoint x="270" y="350" />
      <mxPoint x="270" y="290" />
    </Array>
  </mxGeometry>
</mxCell>
```

**Метки на стрелках:**
- Стрелка вниз (в тело): "Да" или "True"
- Стрелка вправо (выход): "Нет" или "False"

**Визуализация с обозначениями:**
```
                    ┌─── [Предыдущий блок]
                    │
                    ↓  (1) Вход сверху
                    │      При первом входе: выполняет i=0
                    │
        ┌───────────┴───────────┐
        │                       │
(4) ←───┤   i=0; i<n; i++       ├───→ (3) Выход вправо
Возврат │   (шестиугольник)     │      "Нет" / False
слева   │                       │      [Конец цикла]
        └───────────┬───────────┘
   При возврате:   │
   выполняет i++,  │
   проверяет i<n   ↓  (2) Выход вниз
                    │      "Да" / True
                    │
              [Тело цикла]
                    │
                    └──────┐
                           │
                           └→ (возврат к (4))
```

**Логика работы блока цикла:**
1. **Первый вход** (сверху) → выполняется `i = 0`, затем проверяется `i < n`
2. **Если `i < n` истинно** → стрелка вниз в тело цикла
3. **Если `i < n` ложно** → стрелка вправо, выход из цикла
4. **Возврат** (слева) → выполняется `i++`, затем проверяется `i < n`, повторяется п.2-3

### 3.2 Цикл while

**Блок цикла** - ромб с условием (похож на обычное условие, но с возвратом)

Структура:
1. **Условие** (ромб): `условие?`
2. **Тело цикла** (блоки операций)
3. **Возврат** к условию

```
         [вход]
            ↓
    ┌───────────────┐
    ↓               │
  ╱───╲             │
 ╱ усл? ╲ ──(Нет)──→ [Выход]
 ╲     ╱
  ╲───╱
    ↓ (Да)          │
[Тело цикла]        │
    │               │
    └───────────────┘
```

**Отличия от for:**
- Нет встроенной инициализации и инкремента
- Только проверка условия
- Инициализация переменных делается ДО цикла
- Инкремент/изменение делается ВНУТРИ тела цикла

**Сравнениеfor vs while:**
```
FOR:                          WHILE:
                              [i = 0]
                                 ↓
   ╱──────────╲              ╱─────╲
◄──┤i=0;i<n;i++├──►         ◄┤ i<n? ├──►
   ╲─────┬────╱              ╲──┬──╱
         ↓                      ↓
      [тело]                 [тело]
         │                      ↓
         └──►                [i = i+1]
                                │
                                └──►
```

### 3.3 Цикл do-while

```
    ┌─────────────┐
    ↓             │
[Тело цикла]      │
    ↓             │
[Условие?] ───(Да)┘
    ↓ (Нет)
[Выход]
```

## 4. Работа с подпрограммами

### 4.1 Вызов подпрограммы в основной схеме

Используйте блок "процесс" с особым стилем:

```xml
<mxCell style="shape=process;whiteSpace=wrap;html=1;strokeColor=#000000;fontSize=12;align=center;fontStyle=0;fontFamily=Times New Roman;size=0.1;"
        value="Метод Ньютона&#10;(см. стр. 2)" vertex="1">
  <mxGeometry height="50" width="160" x="560" y="240" as="geometry" />
</mxCell>
```

**Рекомендации:**
- Указывайте ссылку на страницу/диаграмму: `(см. стр. 2)`
- Используйте понятные названия: "Метод Кардано", "Сортировка массива"
- Можно добавить параметры: `Метод Ньютона(a, b, c)`

### 4.2 Отдельная диаграмма для подпрограммы

В Draw.io создавайте отдельные вкладки (diagrams) для каждой подпрограммы:

```xml
<diagram name="1. Главная схема" id="main-flowchart">
  ...
</diagram>
<diagram name="2. Метод Ньютона" id="newton-diagram">
  ...
</diagram>
```

**Структура подпрограммы:**
1. **Начало** (овал с названием): `Метод Ньютона`
2. **Входные параметры** (ввод): `a, b, c, d`
3. **Тело алгоритма**
4. **Выходные данные** (вывод): `x (корень)`
5. **Конец** (овал): `Конец`

## 5. Ввод/вывод переменных

### 5.1 Ввод данных

**Правило**: каждая логическая группа переменных в отдельном блоке ввода.

✅ **Правильно:**
```
[Ввод: a]
    ↓
[Ввод: b]
    ↓
[Ввод: c]
```

Или группировка связанных:
```
[Ввод параметров:
 a, b, c, d, k]
```

❌ **Неправильно:**
```
[Ввод всех переменных одновременно без структуры]
```

### 5.2 Промежуточные вычисления

Каждое промежуточное вычисление — отдельный блок процесса:

✅ **Правильно:**
```
[p = a₁ - a₂²/3]
    ↓
[q = 2a₂³/27 - a₁a₂/3 + a₀]
    ↓
[D = Q³ + R²]
```

❌ **Неправильно:**
```
[Вычисление:
 p = a₁ - a₂²/3
 q = 2a₂³/27 - a₁a₂/3 + a₀
 D = Q³ + R²]
```

**Исключение**: если переменные связаны и используются только вместе:
```
[f(x) = ax⁴ + bx³ + cx² + dx + k
 f'(x) = 4ax³ + 3bx² + 2cx + d]
```

### 5.3 Вывод результатов

Четко разделяйте типы вывода:

```
[Вывод: x₁ = 2.5]
    ↓
[Вывод: x₂ = -1.3]
    ↓
[Вывод: "Корни найдены"]
```

Или общий блок:
```
[Вывод результата:
 x₁, x₂, x₃]
```

## 6. Стрелки и переходы

### 6.1 Направление стрелок

- **Основной поток**: сверху вниз
- **Альтернативные ветви**: влево или вправо
- **Возвраты** (циклы): слева обратно вверх

### 6.2 Метки на стрелках

Обязательные метки:
- **От условий**: "Да" / "Нет" или "True" / "False"
- **От множественного выбора**: значения переменной

```xml
<mxCell parent="1" style="text;html=1;fontSize=11;fontFamily=Times New Roman;"
        value="Да" vertex="1">
  <mxGeometry x="490" y="560" width="30" height="20" as="geometry" />
</mxCell>
```

**Позиционирование меток:**
- "Да" — рядом с выходящей стрелкой (внизу от ромба)
- "Нет" — рядом с боковой стрелкой

### 6.3 Параметры стрелок

```xml
<mxCell edge="1" parent="1" source="block1" target="block2"
        style="exitX=0.5;exitY=1;entryX=0.5;entryY=0;strokeWidth=2;">
  <mxGeometry relative="1" as="geometry" />
</mxCell>
```

- **strokeWidth**: 2 пикселя (стандарт)
- **exitX, exitY**: точка выхода (0.5;1 = центр низа)
- **entryX, entryY**: точка входа (0.5;0 = центр верха)

## 7. Чеклист перед финализацией

- [ ] Все блоки выровнены по сетке (10px)
- [ ] Текст черный (#000000), фон белый
- [ ] Шрифт: Times New Roman, 11-12pt
- [ ] Расстояния между блоками: 20-30px
- [ ] Все условия имеют метки "Да"/"Нет"
- [ ] Циклы for оформлены **одним блоком** (шестиугольник) с конструкцией `i=0; i<n; i++`
- [ ] Цикл for имеет 4 стрелки: вход сверху, выход вниз (тело), выход вправо (конец), возврат слева
- [ ] Подпрограммы вынесены на отдельные страницы
- [ ] Каждая промежуточная переменная имеет свой блок или четко обозначена
- [ ] Стрелки имеют толщину 2px
- [ ] Все стрелки ортогональные (прямые углы)
- [ ] Нет пересечений стрелок (по возможности)
- [ ] Начало и конец явно обозначены

## 8. Типичные ошибки

### ❌ Ошибка 1: Слишком много операций в одном блоке
```
[x = a + b
 y = x * 2
 z = y - 3]
```

### ✅ Правильно:
```
[x = a + b] → [y = x * 2] → [z = y - 3]
```

### ❌ Ошибка 2: Разделенная конструкция цикла
```
[i = 0] → [i < n?] → [тело] → [i = i + 1]
```

### ✅ Правильно:
```
        ┌──────────────┐
    ←───┤ i=0; i<n; i++ ├──→ (выход)
        └──────┬───────┘
               ↓
          [тело цикла]
               │
               └──→ (возврат слева)
```

### ❌ Ошибка 3: Отсутствие меток на стрелках
```
[x > 0?] → [процесс A]
         → [процесс B]
```

### ✅ Правильно:
```
[x > 0?] ─(Да)→ [процесс A]
         └(Нет)→ [процесс B]
```

## 9. Пример идеальной структуры

```
┌─────────────┐
│   Начало    │ (овал)
└──────┬──────┘
       ↓
┌─────────────┐
│  Ввод: a    │ (параллелограмм)
└──────┬──────┘
       ↓
┌─────────────┐
│  Ввод: b    │
└──────┬──────┘
       ↓
┌─────────────┐
│ sum = 0     │ (инициализация перед циклом)
└──────┬──────┘
       ↓
    ╱────────────╲
◄───┤ i=0;i<n;i++ ├───► [Конец] (выход: Нет)
    ╲──────┬─────╱
           ↓ (Да)
    ┌─────────────┐
    │ sum = sum+i │
    └──────┬──────┘
           │
           └──→ (возврат в цикл слева)
```

## 10. Дополнительные рекомендации для AI-анализа

1. **Уникальные ID**: используйте понятные ID для блоков (`newton_start`, `check_a`, `for_loop_i`)
2. **Структурированность**: избегайте хаотичного расположения блоков
3. **Комментарии**: добавляйте примечания для сложных формул
4. **Консистентность**: используйте единый стиль во всем документе
5. **Версионирование**: указывайте версию схемы и дату
6. **Цикл for**: ОБЯЗАТЕЛЬНО используйте единый блок-шестиугольник с конструкцией `i=0; i<n; i++`
7. **Точки подключения**: явно указывайте `exitX`, `exitY`, `entryX`, `entryY` для стрелок
8. **Метки направлений**: всегда добавляйте "Да"/"Нет" для условий и циклов

---

**Дата создания**: 19.12.2025
**Версия**: 1.0
**Автор**: Руководство для создания блок-схем, совместимых с AI-анализом

